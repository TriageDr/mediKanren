#lang racket/base
(require racket/set racket/string)

(define argv (current-command-line-arguments))
(define argv-expected '#(DATA_DIR GRAPH_DIR))
(when (not (= (vector-length argv-expected) (vector-length argv)))
  (error "command line argument mismatch:" argv-expected argv))

(define data-dir  (vector-ref argv 0))
(define graph-dir (vector-ref argv 1))
(define (graph-path fname)
  (expand-user-path (build-path data-dir graph-dir fname)))
(define (graph-path/gname fname) (graph-path (string-append graph-dir fname)))

(define (call/files fins fouts p)
  (let loop ((fins fins) (ins '()))
    (if (null? fins)
      (let loop ((fouts fouts) (outs '()))
        (if (null? fouts)
          (apply p (append (reverse ins) (reverse outs)))
          (call-with-output-file
            (car fouts) (lambda (out) (loop (cdr fouts) (cons out outs))))))
      (call-with-input-file
        (car fins) (lambda (in) (loop (cdr fins) (cons in ins)))))))

(define-syntax-rule (let/files ((in fin) ...) ((out fout) ...) body ...)
  (call/files (list fin ...) (list fout ...)
              (lambda (in ... out ...) body ...)))

(define (csv-escape s)
  (string-append "\"" (string-replace s "\"" "\"\"") "\""))

(let/files ((in-edges (graph-path "edges.input.scm")))
  ((out-node     (graph-path/gname ".node.csv"))
   (out-nodeprop (graph-path/gname ".nodeprop.csv"))
   (out-edge     (graph-path/gname ".edge.csv"))
   (out-edgeprop (graph-path/gname ".edgeprop.csv")))
  (fprintf out-node     ":ID\n")
  (fprintf out-nodeprop ":ID,propname,value\n")
  (fprintf out-edge     ":ID,:START,:END\n")
  (fprintf out-edgeprop ":ID,propname,value\n")
  (let loop ((i 0) (concepts (set)))
    (define (add-concept concepts c)
      (define curie    (car    c))
      (define name     (cadr   c))
      (define category (caddr  c))
      (define cprops   (cadddr c))
      (cond ((set-member? concepts curie) concepts)
            (else (fprintf out-node "~a\n" curie)
                  (fprintf out-nodeprop "~a,~a,~a\n" curie "name"
                           (csv-escape name))
                  (fprintf out-nodeprop "~a,~a,~a\n" curie "category"
                           (csv-escape category))
                  (for-each (lambda (kv)
                              (fprintf out-nodeprop "~a,~a,~a\n" curie
                                       (car kv) (csv-escape (cdr kv))))
                            cprops)
                  (set-add concepts curie))))
    (define e (read in-edges))
    (unless (eof-object? e)
      (define subject   (car    e))
      (define object    (cadr   e))
      (define predicate (caddr  e))
      (define eprops    (cadddr e))
      (fprintf out-edge "~a,~a,~a\n" i (car subject) (car object))
      (fprintf out-edgeprop "~a,~a,~a\n" i "edge_label" predicate)
      (for-each (lambda (kv) (fprintf out-edgeprop "~a,~a,~a\n" i (car kv)
                                      (csv-escape (cdr kv))))
                eprops)
      (loop (+ i 1) (add-concept (add-concept concepts subject) object)))))
